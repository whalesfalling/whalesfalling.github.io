[{"title":"设计模式的七大原则——迪米特法则(下)","date":"2020-11-17T15:06:15.000Z","path":"2020/11/17/20201117-005.html","text":"迪米特法则: 最少知道原则，即一个类对自己依赖的类知道的越少越好 迪米特法则代码2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * 学校总部员工类 */ class Employee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工类 */ class CollegeEmployee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工管理类 */ class CollegeManager &#123; // 分院员工列表 public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; List&lt;CollegeEmployee&gt; employeeList = new ArrayList&lt;CollegeEmployee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; CollegeEmployee employee = new CollegeEmployee(); employee.setId(\" 分院员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; /** * 输出分院员工列表 */ void printAllEmployee() &#123; List&lt;CollegeEmployee&gt; employeeList = getAllEmployee(); System.out.println(\"-分院员工列表------------- \"); for (CollegeEmployee c : employeeList) &#123; System.out.println(c.getId()); &#125; &#125; &#125; /** * 学校总部员工管理类 */ class SchoolManager &#123; // 总院员工列表 public List&lt;Employee&gt; getAllEmployee() &#123; List&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; Employee employee = new Employee(); employee.setId(\" 总部员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; /** * 输出所有员工列表 */ void printAllEmployee(CollegeManager collegeManager) &#123; // 输出分院员工列表 collegeManager.printAllEmployee(); // 输出所有员工列表 List&lt;Employee&gt; employeeList2 = this.getAllEmployee(); System.out.println(\"-总院员工列表------------- \"); for (Employee c : employeeList2) &#123; System.out.println(c.getId()); &#125; &#125; &#125; public static void main(String[] args) &#123; SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManager()); &#125; 注意事项： 迪米特法则的核心是降低类之间的耦合； 由于每个类都减少了必要的依赖，但是迪米特法则只是要求降低类间(对象间)的耦合，并不是要求完全没有依赖关系；","tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://whalesfalling.github.io/tags/底层原理/"}]},{"title":"设计模式的七大原则——迪米特法则(上)","date":"2020-11-17T15:06:15.000Z","path":"2020/11/17/20201117-004.html","text":"迪米特法则: 最少知道原则，即一个类对自己依赖的类知道的越少越好 迪米特法则代码1:(违反了迪米特法则，不推荐使用) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /** * 学校总部员工类 */ class Employee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工类 */ class CollegeEmployee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工管理类 */ class CollegeManager &#123; // 分院员工列表 public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; List&lt;CollegeEmployee&gt; employeeList = new ArrayList&lt;CollegeEmployee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; CollegeEmployee employee = new CollegeEmployee(); employee.setId(\" 分院员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; &#125; /** * 学校总部员工管理类 */ class SchoolManager &#123; // 总院员工列表 public List&lt;Employee&gt; getAllEmployee() &#123; List&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; Employee employee = new Employee(); employee.setId(\" 总部员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; /** * CollegeManager 和 SchoolManager 不是直接的关系， CollegeManager 是以局部变量出现在 * SchoolManager， 违反了迪米特法则 * * @param collegeManager */ void printAllEmployee(CollegeManager collegeManager) &#123; List&lt;CollegeEmployee&gt; employeeList = collegeManager.getAllEmployee(); System.out.println(\"-分院员工列表------------- \"); for (CollegeEmployee c : employeeList) &#123; System.out.println(c.getId()); &#125; List&lt;Employee&gt; employeeList2 = this.getAllEmployee(); System.out.println(\"-总院员工列表------------- \"); for (Employee c : employeeList2) &#123; System.out.println(c.getId()); &#125; &#125; &#125; public static void main(String[] args) &#123; SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManager()); &#125; 解析：对于被依赖的类，不管有多么复杂，都尽量将逻辑封装在类的内部对外除了提供public方法，不对外泄露任何信息；上方代码CollegeManager 和 SchoolManager 不是直接的关系，违反了迪米特法则；","tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://whalesfalling.github.io/tags/底层原理/"}]},{"title":"设计模式的七大原则——迪米特法则(上)","date":"2020-11-17T15:06:15.000Z","path":"2020/11/17/20201117-006.html","text":"迪米特法则: 最少知道原则，即一个类对自己依赖的类知道的越少越好 迪米特法则代码1:(违反了迪米特法则，不推荐使用) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /** * 学校总部员工类 */ class Employee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工类 */ class CollegeEmployee &#123; // 员工编号 private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; /** * 学校分院员工管理类 */ class CollegeManager &#123; // 分院员工列表 public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; List&lt;CollegeEmployee&gt; employeeList = new ArrayList&lt;CollegeEmployee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; CollegeEmployee employee = new CollegeEmployee(); employee.setId(\" 分院员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; &#125; /** * 学校总部员工管理类 */ class SchoolManager &#123; // 总院员工列表 public List&lt;Employee&gt; getAllEmployee() &#123; List&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; Employee employee = new Employee(); employee.setId(\" 总部员工编号 = \" + i); employeeList.add(employee); &#125; return employeeList; &#125; /** * CollegeManager 和 SchoolManager 不是直接的关系， CollegeManager 是以局部变量出现在 * SchoolManager， 违反了迪米特法则 * * @param collegeManager */ void printAllEmployee(CollegeManager collegeManager) &#123; List&lt;CollegeEmployee&gt; employeeList = collegeManager.getAllEmployee(); System.out.println(\"-分院员工列表------------- \"); for (CollegeEmployee c : employeeList) &#123; System.out.println(c.getId()); &#125; List&lt;Employee&gt; employeeList2 = this.getAllEmployee(); System.out.println(\"-总院员工列表------------- \"); for (Employee c : employeeList2) &#123; System.out.println(c.getId()); &#125; &#125; &#125; public static void main(String[] args) &#123; SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManager()); &#125; 解析：对于被依赖的类，不管有多么复杂，都尽量将逻辑封装在类的内部对外除了提供public方法，不对外泄露任何信息；上方代码CollegeManager 和 SchoolManager 不是直接的关系，违反了迪米特法则；","tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://whalesfalling.github.io/tags/底层原理/"}]},{"title":"前端框架 VUE 开发指引","date":"2020-11-17T15:04:51.000Z","path":"2020/11/17/20201117-003.html","text":"1. vue页面加载时，v-if标签导致页面闪频解决 页面添加style,并在 v-if 标签添加调用： 1 2 3 4 5 6 7 [v-cloak] &#123; /* display: none !important; */ visibility: hidden !important; &#125; 个人建议使用 visibility: hidden ，因为只是显示问题，没必要使用 display: none , 程度没那么严重； 2. css 字体粗细问题 1 2 3 font-weight: bolder; // 更粗字体 font-weight: bold; // 粗字体 3. css 背景透明 1 background: transparent; 4. 去除原生 select 下拉框的边框和倒三角 1 2 border: 0; // 去除边框 -webkit-appearance: none; // 去除倒三角 5. div 内容上下左右居中 1 2 3 display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; 6. select 下拉框内容靠右 text-align: right; 不生效问题 1 direction: rtl; 7. 按钮圆角 1 -webkit-border-radius: 3rem; rem 大小根据实际情况自行定义","tags":[{"name":"问题总结","slug":"问题总结","permalink":"https://whalesfalling.github.io/tags/问题总结/"}]},{"title":"前端框架 VUE 开发问题总结","date":"2020-11-17T12:45:31.000Z","path":"2020/11/17/20201117-002.html","text":"页面属性渲染问题在 vue 的开发中, 我们最常用的是 vue 的双向绑定的属性，我们将属性定义在 data () { 属性名：属性默认值 } 中，同时在页面中使用 ，vue 在加载时会将默认值渲染到 中进行显示，当在 js 中通过 this.属性名 = XXX 进行修改值时， 会被实时同步修改显示，如果在开发中遇到修改值，页面未同步改变问题时，需要排查当前 this 的指向问题，看当前的 this 是否指定的是全局的，这里推荐是用箭头函数： 方法名 = (传入参数值) =&gt; { this.属性名 = xxx } 的方式进行修改，在此箭头函数中 this 永远指向的是全局的。如果还是遇到无法同步渲染的问题，就需要排查定义的属性，修改的属性，页面显示的属性是否大小写一致，是否完全相同等。 集合修改其中一项的值，页面未同步渲染问题我们在 vue 的开发中往往需要修改集合中某一项的值，如:下拉框的选中属性，当我们将集合中的其中一项进行修改后，js 通过 log 输出的值发生改变，页面显示却无变化时，我们可以使用 this.$ set() 方法进行渲染集合，此方法的语法如下：this.$ set(this.需要修改的集合，集合中需要修改项的下标，修改项的值) 通过此方法，集合中的参数发生变化时，页面也会进行同步渲染。","tags":[{"name":"问题总结","slug":"问题总结","permalink":"https://whalesfalling.github.io/tags/问题总结/"}]},{"title":"HashMap底层原理","date":"2020-11-17T12:45:31.000Z","path":"2020/11/17/20201117-001.html","text":"1.HashMap 的底层是数组1 2 3 4 5 6 7 // 参考代码 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.push(\"张三\"，\"测试数据1\"); map.push(\"李四\"，\"测试数据2\"); // 底层的数据类型简单展示，当然实际上远远没有这么简单，这里是方便理解 [&lt;张三， 测试数据1&gt;, &lt;李四， 测试数据2&gt;] 2.底层原理1 2 3 4 5 6 7 8 1. 首先会根据'张三'这个 key 计算出它的 Hash 值； 2. 拿到 Hash 值对数组的长度进行取模（数组是有固定长度的），定位到将要存入的数组中的指定位置； [&lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;张三, 测试数据1&gt;, &lt;&gt;, &lt;李四, 测试数据2&gt;, &lt;&gt;] 3. 取值原理也是先计算处 Hash 值后进行取模，拿到指定下标获取元素； 4. 实际上 JDK 中 HashMap 的原理要比以上的逻辑复杂一些，还有一些防止 Hash 重复，数组扩容的操作等等； 3.JDK 1.8中对Hash算法和寻址算法的优化1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 代码示例 map.push(\"张三\", \"测试数据\"); // 1.在 JDK 1.8 中对 “张三” 这个 key 计算 Hash 值是有一定的优化的 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (key.hashCode())^(h &gt;&gt;&gt; 16); &#125; // 比如说： 存在一个 key 的 hash 值 // 1111 1111 1111 1111 1111 1010 0111 1100 // 右移16位（h &gt;&gt;&gt; 16）: // 0000 0000 0000 0000 1111 1111 1111 1111 // 将两个 hash 进行异或运算（对比是否一样）得出新的 hash 值： // 1111 1111 1111 1111 0000 0101 1000 0011 // 将转换后的异或 hash（32位） 值转int（32位）进行返回； // 2. 寻址算法优化： n 数组长度 (n -1) &amp; hash // 假设数组的长度为 16 位，(n -1) &amp; hash 算出的 hash 值如下： // 0000 0000 0000 0000 0000 0000 0000 1111 // 没有经过优化 key 的 Hash 值如下： // 1111 1111 1111 1111 1111 1010 0111 1100 // 优化后的新 hash 值： // 1111 1111 1111 1111 0000 0101 1000 0011 // 取模的运算性能比较差，(n -1) &amp; hash 运算的效果和取模是一样的， 但是性能比取模高的多； // 如果使用没有优化过的 hash 值进行 &amp; 运算，两个值的区别很小，容易出现多个 key 算出的位置是一样的情况，因此要进行异或运算 4.总结 Hash 算法的优化： 对每个 hash 值，在他的低 16 位中， 让他的高低 16 位都进行异或运算， 让他的低 16 位同时保持了 高 16 位的特征，尽量避免了一些 hash 值后续出现的冲突，即多个不同的 key 存入同一个数组位置 寻址算法的优化： 用 &amp; 运算代替了取模运算，提高了运算的性能；","tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://whalesfalling.github.io/tags/底层原理/"}]},{"title":"编程小技巧 - @Data与@Slf4j的使用","date":"2019-04-25T01:20:56.000Z","path":"2019/04/25/theBk-20190425.html","text":"前言​ 最近在项目中发现两个很好使用的注解，在这里分享给大家； 描述​ @Data: 使用此注解后，自动生成setter、getter方法； ​ @slf4: 如果不想每次都写Logger,可以用注解@Slf4j 1 private final Logger logger = LoggerFactory.getLogger(XXX.class); 代码在pom文件加入依赖 1 2 3 4 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; @Data: 未使用@data之前： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class EnergySource &#123; private String A; private String B; private String C public String getA() &#123; return A; &#125; public String getB() &#123; return B; &#125; public String getC() &#123; return C; &#125; public void setA(String a) &#123; this.A = a; &#125; public void setB(String b) &#123; this.B= b; &#125; public void setC(String c) &#123; this.C= C; &#125; 使用了@Data注解以后 1 2 3 4 5 6 7 8 import lombok.Data; @Data public class EnergySource &#123; private String a; private String b; private String c; &#125; 很明显，代码简洁了许多，看上去不会太复杂。不过这里需要在IDE中配置好lombok，由此看来，一些工具的使用可以大大增加业务逻辑的清晰度。 @Slf4j: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.sell; import lombok.extern.slf4j.Slf4j; import org.junit.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; /** * 日志测试 */ @RunWith(SpringRunner.class) @SpringBootTest @Slf4j public class LoggerTest &#123; private final Logger logger = LoggerFactory.getLogger(LoggerTest.class); /** * 一、传统方式实现日志 */ @Test public void test1()&#123; logger.debug(\"debug message\"); logger.warn(\"warn message\"); logger.info(\"info message\"); logger.error(\"error message\"); logger.trace(\"trace message\"); &#125; /** * 二、注解方式实现日志 */ @Test public void test2()&#123; log.debug(\"debug message\"); log.warn(\"warn message\"); log.info(\"info message\"); log.error(\"error message\"); log.trace(\"trace message\"); &#125; &#125; 输出如下： 注意：如果注解@Slf4j注入后找不到变量log，那就给IDE安装lombok插件 下面以idea为例 1、File → settings → Plugins, 然后点击“Browse repositories” 如图 2、输入 lombok 搜索插件， 点install安装，安装完重启idea 这时候输入 log就可以有提示了","tags":[{"name":"编程小技巧","slug":"编程小技巧","permalink":"https://whalesfalling.github.io/tags/编程小技巧/"}]},{"title":"并发编程-synchronized关键字的使用","date":"2019-03-31T07:34:35.000Z","path":"2019/03/31/use-synchronized.html","text":"前言​ 在工作中，我们经常会使用到并发编程，synchronized，volatile，ReentranLock，concurrent这几个关键字下的包相信大部分程序员都听说过，这些看似高深的代名词，很多人都不懂得如何去使用，滥用的结果往往都需要自己承担后果。在本章中，为大家讲解 synchronized 关键字的使用。 描述​ 我看过许多关于线程安全方面的书籍，上面对线程安全描述的很笼统，最近在一本老外写的书上，看到对线程安全的很形象描述： 线程安全的概念：当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 sysnchronized: 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。 代码示例1 2 3 4 5 6 7 8 public class MyThread extends Thread&#123; private int count = 5; // synchronized加锁 public void run()&#123; count--; System.out.println(this.currentThread().getName() + \" count = \" + count); &#125; &#125; ​ 我们来读一下这段代码，首先我新建了一个名为 MyThread 的类，并且让这个类继承了 Thread ，在这个类中定义了一个私有变量 count ，初始值为5，定义了一个 run() 方法，在这个方法里面对 count 进行了 – 操作,然后输出线程的名称和 count 的值。 ​ 我们用一个 main 方法来测试一下这个类： 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread,\"t1\"); Thread t2 = new Thread(myThread,\"t2\"); Thread t3 = new Thread(myThread,\"t3\"); Thread t4 = new Thread(myThread,\"t4\"); Thread t5 = new Thread(myThread,\"t5\"); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125; ​ 输出结果如下： 1 2 3 4 5 t3 count = 2 t5 count = 0 t2 count = 1 t1 count = 1 t4 count = 1 ​ 这个结果和我们预期输出的结果是不相符的，我们称它为 非线程安全 的，所以我们在 run() 方法上加上 synchronized 关键字，我们再来看下输出的结果： 1 2 3 4 5 6 7 8 public class MyThread extends Thread&#123; private int count = 5; // synchronized加锁 public synchronized void run()&#123; count--; System.out.println(this.currentThread().getName() + \" count = \" + count); &#125; &#125; ​ 输出结果如下，我们称它为 线程安全 的： 1 2 3 4 5 t1 count = 4 t5 count = 3 t4 count = 2 t3 count = 1 t2 count = 0 结果分析 ​ 当多个线程访问 MyThread 的 run() 方法时，会以排队的方式进行处理（这里排队的方式是指CPU分配的先后顺序而定的），一个线程想要执行 synchronized 关键字修饰的方法里的代码： 尝试获得锁； 如果拿到锁，执行 synchronized 代码块里的内容；拿不到锁，会去不断尝试获取这把锁，直到拿到锁为止，而且时多个线程同时去竞争这把锁（也就是会出现 锁竞争 问题）。 备注锁竞争：即1000个或1000个以上的线程同时访问同一个线程，其中第一个获得后，其他的999个线程同时去竞争第一个调用完成后释放的锁，造成CPU的使用率特别高，系统出现卡顿，宕机的问题，一般出现在大型企业系统中，后面会讲到如何去解决这个问题。","tags":[{"name":"synchronized","slug":"synchronized","permalink":"https://whalesfalling.github.io/tags/synchronized/"}]},{"title":"IDEA SPringBoot 整合H5微信支付","date":"2019-03-25T02:00:54.000Z","path":"2019/03/25/IDEA-SPringBoot-H5WXZF.html","text":"前言​ 上周由于项目需要开通H5微信支付功能，于是在网上参考了很多例子，由于数据缺失，实用性不高，所以在此特地将SpringBoot整合H5微信支付的流程整理成文档，测试可用。 场景介绍​ H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。 ​ 主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付。 ​ 申请入口：登录商户平台–&gt;产品中心–&gt;我的产品–&gt;支付产品–&gt;H5支付 ​ 注意：需要开通H5支付，并且做一些配置 ​ 微信官方体验链接：https://wxpay.wxutil.com/mch/pay/h5.v2.php，请在微信外浏览器打开。 1、用户在商户侧完成下单，使用微信支付进行支付 2、由商户后台向微信支付发起下单请求（调用统一下单接口）注：交易类型trade_type=MWEB 3、统一下单接口返回支付相关参数给商户后台，如支付跳转url（参数名“mweb_url”），商户通过mweb_url调起微信支付中间页 4、中间页进行H5权限的校验，安全性检查（此处常见错误请见下文） 5、如支付成功，商户后台会接收到微信侧的异步通知 6、用户在微信支付收银台完成支付或取消支付,返回商户页面（默认为返回支付发起页面） 7、商户在展示页面，引导用户主动发起支付结果的查询 8、商户后台判断是否接到收微信侧的支付结果通知，如没有，后台调用我们的订单查询接口确认订单状态 9、展示最终的订单支付结果给用户 H5支付文档 集成H5微信支付1.导入依赖jar包1 2 3 4 5 6 7 8 9 10 11 &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; 2. application.yml1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 测试账号 pay: wxpay: appID: wxab8acb865bb1637e mchID: 11473623 key: 2ab9071b06b9f739b950ddb41db2690d sandboxKey: 3639bc1370e105aa65f10cd4fef2a3ef certPath: /var/local/cert/apiclient_cert.p12 notifyUrl: http://65ta5j.natappfree.cc/wxpay/refund/notify useSandbox: true spring: thymeleaf: prefix: classpath:/templates/ suffix: .html mode: HTML5 encoding: UTF-8 3. WebMvcConfiguration1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123; @Override protected void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/gotoWapPage\").setViewName(\"gotoWapPay\"); registry.addViewController(\"/gotoPagePage\").setViewName(\"gotoPagePay\"); registry.addViewController(\"/gotoH5Page\").setViewName(\"gotoH5Page\"); registry.addViewController(\"/h5PaySuccess\").setViewName(\"h5PaySuccess\"); super.addViewControllers(registry); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); super.addResourceHandlers(registry); &#125; &#125; 4. MyWXPayConfig1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 微信支付的参数配置 * * @author mengday zhang */ @Data @Slf4j @ConfigurationProperties(prefix = \"pay.wxpay\") public class MyWXPayConfig implements WXPayConfig&#123; /** 公众账号ID */ private String appID; /** 商户号 */ private String mchID; /** API 密钥 */ private String key; /** API 沙箱环境密钥 */ private String sandboxKey; /** API证书绝对路径 */ private String certPath; /** 退款异步通知地址 */ private String notifyUrl; private Boolean useSandbox; /** HTTP(S) 连接超时时间，单位毫秒 */ private int httpConnectTimeoutMs = 8000; /** HTTP(S) 读数据超时时间，单位毫秒 */ private int httpReadTimeoutMs = 10000; /** * 获取商户证书内容 * * @return 商户证书内容 */ @Override public InputStream getCertStream() &#123; File certFile = new File(certPath); InputStream inputStream = null; try &#123; inputStream = new FileInputStream(certFile); &#125; catch (FileNotFoundException e) &#123; log.error(\"cert file not found, path=&#123;&#125;, exception is:&#123;&#125;\", certPath, e); &#125; return inputStream; &#125; @Override public String getKey()&#123; if (useSandbox) &#123; return sandboxKey; &#125; return key; &#125; &#125; 5. WXPayClient1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 /** * WXPayClient * &lt;p&gt; * 对WXPay的简单封装，处理支付密切相关的逻辑. * * @author Mengday Zhang * @version 1.0 * @since 2018/6/16 */ @Slf4j public class WXPayClient extends WXPay &#123; /** 密钥算法 */ private static final String ALGORITHM = \"AES\"; /** 加解密算法/工作模式/填充方式 */ private static final String ALGORITHM_MODE_PADDING = \"AES/ECB/PKCS5Padding\"; /** 用户支付中，需要输入密码 */ private static final String ERR_CODE_USERPAYING = \"USERPAYING\"; private static final String ERR_CODE_AUTHCODEEXPIRE = \"AUTHCODEEXPIRE\"; /** 交易状态: 未支付 */ private static final String TRADE_STATE_NOTPAY = \"NOTPAY\"; /** 用户输入密码，尝试30秒内去查询支付结果 */ private static Integer remainingTimeMs = 10000; private WXPayConfig config; public WXPayClient(WXPayConfig config, WXPayConstants.SignType signType, boolean useSandbox) &#123; super(config, signType, useSandbox); this.config = config; &#125; /** * * 刷卡支付 * * 对WXPay#microPay(Map)增加了当支付结果为USERPAYING时去轮询查询支付结果的逻辑处理 * * 注意：该方法没有处理return_code=FAIL的情况，暂时不考虑网络问题，这种情况直接返回错误 * * @param reqData * @return * @throws Exception */ public Map&lt;String, String&gt; microPayWithPOS(Map&lt;String, String&gt; reqData) throws Exception &#123; // 开始时间(毫秒) long startTimestampMs = System.currentTimeMillis(); Map&lt;String, String&gt; responseMapForPay = super.microPay(reqData); log.info(responseMapForPay.toString()); // // 先判断 协议字段返回(return_code)，再判断 业务返回，最后判断 交易状态(trade_state) // 通信标识，非交易标识 String returnCode = responseMapForPay.get(\"return_code\"); if (WXPayConstants.SUCCESS.equals(returnCode)) &#123; String errCode = responseMapForPay.get(\"err_code\"); // 余额不足，信用卡失效 if (ERR_CODE_USERPAYING.equals(errCode) || \"SYSTEMERROR\".equals(errCode) || \"BANKERROR\".equals(errCode)) &#123; Map&lt;String, String&gt; orderQueryMap = null; Map&lt;String, String&gt; requestData = new HashMap&lt;&gt;(); requestData.put(\"out_trade_no\", reqData.get(\"out_trade_no\")); // 用户支付中，需要输入密码或系统错误则去重新查询订单API err_code, result_code, err_code_des // 每次循环时的当前系统时间 - 开始时记录的时间 &gt; 设定的30秒时间就退出 while (System.currentTimeMillis() - startTimestampMs &lt; remainingTimeMs) &#123; // 商户收银台得到USERPAYING状态后，经过商户后台系统调用【查询订单API】查询实际支付结果。 orderQueryMap = super.orderQuery(requestData); String returnCodeForQuery = orderQueryMap.get(\"return_code\"); if (WXPayConstants.SUCCESS.equals(returnCodeForQuery)) &#123; // 通讯成功 String tradeState = orderQueryMap.get(\"trade_state\"); if (WXPayConstants.SUCCESS.equals(tradeState)) &#123; // 如果成功了直接将查询结果返回 return orderQueryMap; &#125; // 如果支付结果仍为USERPAYING，则每隔5秒循环调用【查询订单API】判断实际支付结果 Thread.sleep(1000); &#125; &#125; // 如果用户取消支付或累计30秒用户都未支付，商户收银台退出查询流程后继续调用【撤销订单API】撤销支付交易。 String tradeState = orderQueryMap.get(\"trade_state\"); if (TRADE_STATE_NOTPAY.equals(tradeState) || ERR_CODE_USERPAYING.equals(tradeState) || ERR_CODE_AUTHCODEEXPIRE.equals(tradeState)) &#123; Map&lt;String, String&gt; reverseMap = this.reverse(requestData); String returnCodeForReverse = reverseMap.get(\"return_code\"); String resultCode = reverseMap.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCodeForReverse) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; // 如果撤销成功，需要告诉客户端已经撤销订单了 responseMapForPay.put(\"err_code_des\", \"用户取消支付或尚未支付，后台已经撤销该订单，请重新支付！\"); &#125; &#125; &#125; &#125; return responseMapForPay; &#125; /** * 从request的inputStream中获取参数 * @param request * @return * @throws Exception */ public Map&lt;String, String&gt; getNotifyParameter(HttpServletRequest request) throws Exception &#123; InputStream inputStream = request.getInputStream(); ByteArrayOutputStream outSteam = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) &#123; outSteam.write(buffer, 0, length); &#125; outSteam.close(); inputStream.close(); // 获取微信调用我们notify_url的返回信息 String resultXml = new String(outSteam.toByteArray(), \"utf-8\"); Map&lt;String, String&gt; notifyMap = WXPayUtil.xmlToMap(resultXml); return notifyMap; &#125; /** * 解密退款通知 * * &lt;a href=\"https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_16&amp;index=11&gt;退款结果通知文档&lt;/a&gt; * @return * @throws Exception */ public Map&lt;String, String&gt; decodeRefundNotify(HttpServletRequest request) throws Exception &#123; // 从request的流中获取参数 Map&lt;String, String&gt; notifyMap = this.getNotifyParameter(request); log.info(notifyMap.toString()); String reqInfo = notifyMap.get(\"req_info\"); //（1）对加密串A做base64解码，得到加密串B byte[] bytes = new BASE64Decoder().decodeBuffer(reqInfo); //（2）对商户key做md5，得到32位小写key* ( key设置路径：微信商户平台(pay.weixin.qq.com)--&gt;账户设置--&gt;API安全--&gt;密钥设置 ) Cipher cipher = Cipher.getInstance(ALGORITHM_MODE_PADDING); SecretKeySpec key = new SecretKeySpec(WXPayUtil.MD5(config.getKey()).toLowerCase().getBytes(), ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); //（3）用key*对加密串B做AES-256-ECB解密（PKCS7Padding） // java.security.InvalidKeyException: Illegal key size or default parameters // https://www.cnblogs.com/yaks/p/5608358.html String responseXml = new String(cipher.doFinal(bytes),\"UTF-8\"); Map&lt;String, String&gt; responseMap = WXPayUtil.xmlToMap(responseXml); return responseMap; &#125; /** * 获取沙箱环境验签秘钥API * &lt;a href=\"https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=23_1\"&gt;获取验签秘钥API文档&lt;/a&gt; * @return * @throws Exception */ public Map&lt;String, String&gt; getSignKey() throws Exception &#123; Map&lt;String, String&gt; reqData = new HashMap&lt;&gt;(); reqData.put(\"mch_id\", config.getMchID()); reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr()); String sign = WXPayUtil.generateSignature(reqData, config.getKey(), WXPayConstants.SignType.MD5); reqData.put(\"sign\", sign); String responseXml = this.requestWithoutCert(\"https://api.mch.weixin.qq.com/sandboxnew/pay/getsignkey\", reqData, config.getHttpConnectTimeoutMs(), config.getHttpReadTimeoutMs()); Map&lt;String, String&gt; responseMap = WXPayUtil.xmlToMap(responseXml); return responseMap; &#125; &#125; 6. WXPayConfiguration1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 微信支付配置 * * @author mengday zhang */ @Configuration @EnableConfigurationProperties(MyWXPayConfig.class) public class WXPayConfiguration &#123; @Autowired private MyWXPayConfig wxPayConfig; /** * useSandbox 沙盒环境 * @return */ @Bean public WXPay wxPay() &#123; return new WXPay(wxPayConfig, WXPayConstants.SignType.MD5, wxPayConfig.getUseSandbox() ); &#125; @Bean public WXPayClient wxPayClient() &#123; return new WXPayClient(wxPayConfig, WXPayConstants.SignType.MD5, wxPayConfig.getUseSandbox()); &#125; &#125; 7. gotoH5Page.html1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body style=\"font-size: 30px\"&gt; &lt;h3&gt;购买商品：可口可乐&lt;/h3&gt; &lt;h3&gt;价格：4&lt;/h3&gt; &lt;h3&gt;数量：10个&lt;/h3&gt; &lt;button style=\"width: 100%; height: 60px; alignment: center; background: #b49e8f\" onclick=\"commitOrder()\"&gt;提交订单&lt;/button&gt; &lt;script src=\"http://localhost:8080/webjars/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; function commitOrder() &#123; $.ajax(&#123; type: \"POST\", url: \"http://localhost:8080/wxpay/h5pay/order\", data: null, success: function(data) &#123; console.log(data); var redirectUrl = \"http://localhost:8080/h5PaySuccess\"; var mwebUrl = data.mweb_url+\"&amp;redirect_url=\"+encodeURIComponent(redirectUrl); window.location.href=mwebUrl; &#125; &#125;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 8. h5PaySuccess.html1 2 3 4 5 6 7 8 9 10 11 12 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;微信支付-H5支付成功&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 9. WXPayH5PayController1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /** * 微信支付-H5支付. * &lt;p&gt; * detailed description * * @author Mengday Zhang * @version 1.0 * @since 2018/6/18 */ @Slf4j @RestController @RequestMapping(\"/wxpay/h5pay\") public class WXPayH5PayController &#123; @Autowired private WXPay wxPay; @Autowired private WXPayClient wxPayClient; /** * 使用沙箱支付的金额必须是用例中指定的金额，也就是 1.01 元，1.02元等，不能是你自己的商品的实际价格，必须是这个数。 * 否则会报错：沙箱支付金额(2000)无效，请检查需要验收的case * @return * @throws Exception */ @PostMapping(\"/order\") public Object h5pay() throws Exception &#123; Map&lt;String, String&gt; reqData = new HashMap&lt;&gt;(); reqData.put(\"out_trade_no\", String.valueOf(System.nanoTime())); reqData.put(\"trade_type\", \"MWEB\"); reqData.put(\"product_id\", \"1\"); reqData.put(\"body\", \"商户下单\"); // 订单总金额，单位为分 reqData.put(\"total_fee\", \"101\"); // APP和网页支付提交用户端ip，Native支付填调用微信支付API的机器IP。 reqData.put(\"spbill_create_ip\", \"14.23.150.211\"); // 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。 reqData.put(\"notify_url\", \"http://3sbqi7.natappfree.cc/wxpay/h5pay/notify\"); // 自定义参数, 可以为终端设备号(门店号或收银设备ID)，PC网页或公众号内支付可以传\"WEB\" reqData.put(\"device_info\", \"\"); // 附加数据，在查询API和支付通知中原样返回，可作为自定义参数使用。 reqData.put(\"attach\", \"\"); reqData.put(\"scene_info\", \"&#123;\\\"h5_info\\\": &#123;\\\"type\\\":\\\"Wap\\\",\\\"wap_url\\\": \\\"http://3sbqi7.natappfree.cc\\\",\\\"wap_name\\\": \\\"腾讯充值\\\"&#125;&#125;\"); Map&lt;String, String&gt; responseMap = wxPay.unifiedOrder(reqData); log.info(responseMap.toString()); String returnCode = responseMap.get(\"return_code\"); String resultCode = responseMap.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCode) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; // 预支付交易会话标识 String prepayId = responseMap.get(\"prepay_id\"); // 支付跳转链接(前端需要在该地址上拼接redirect_url,该参数不是必须的) // 正常流程用户支付完成后会返回至发起支付的页面，如需返回至指定页面，则可以在MWEB_URL后拼接上redirect_url参数，来指定回调页面 // 需对redirect_url进行urlencode处理 // TODO 正常情况下这里应该是普通的链接，不知道这里为何是weixin://这样的链接，不知道是不是微信公众平台上的配置少配置了； // 由于没有实际账号，还没找到为啥不是普通链接的原因 String mwebUrl = responseMap.get(\"mweb_url\"); &#125; return responseMap; &#125; /** * 注意：如果是沙箱环境，一提交订单就会立即异步通知，而无需拉起微信支付收银台的中间页面 * @param request * @throws Exception */ @RequestMapping(\"/notify\") public void payNotify(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; Map&lt;String, String&gt; reqData = wxPayClient.getNotifyParameter(request); log.info(reqData.toString()); String returnCode = reqData.get(\"return_code\"); String resultCode = reqData.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCode) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; boolean signatureValid = wxPay.isPayResultNotifySignatureValid(reqData); if (signatureValid) &#123; // TODO 业务处理 Map&lt;String, String&gt; responseMap = new HashMap&lt;&gt;(2); responseMap.put(\"return_code\", \"SUCCESS\"); responseMap.put(\"return_msg\", \"OK\"); String responseXml = WXPayUtil.mapToXml(responseMap); response.setContentType(\"text/xml\"); response.getWriter().write(responseXml); response.flushBuffer(); &#125; &#125; &#125; &#125; 常见问题1.@Data @Slf4j标签的引用 参考 IntelliJ IDEA lombok插件的安装和使用 2.微信支付常见错误 参考 微信官方文档 微信支付常见问题 微信返回错误提示 3.沙箱环境说明 参考 浅析微信支付：如何使用沙箱环境测试 注意：本文档中 useSandbox: true 为沙箱测试环境，返回微信地址为 weixin://这样的链接，提交订单就会立即异步通知，不会拉起微信支付收银台的中间页面，当 useSandbox: false 时，切换为生产环境，浏览器会跳转至微信支付收银台的中间页面。 回调页面​ 正常流程用户支付完成后会返回至发起支付的页面，如需返回至指定页面，则可以在MWEB_URL后拼接上redirect_url参数，来指定回调页面。 如： ​ 您希望用户支付完成后跳转至https://www.wechatpay.com.cn，则可以做如下处理： ​ 假设您通过统一下单接口获到的MWEB_URL= https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx20161110163838f231619da20804912345&amp;package=1037687096 ​ 则拼接后的地址为MWEB_URL= https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx20161110163838f231619da20804912345&amp;package=1037687096&amp;redirect_url=https%3A%2F%2Fwww.wechatpay.com.cn 注意： 注意MWEB_URL是普通的链接，不是微信weixin://短链接（useSandbox: false）需对redirect_url进行urlencode处理由于设置redirect_url后,回跳指定页面的操作可能发生在： 微信支付中间页调起微信收银台后超过5秒 用户点击“取消支付“或支付完成后点“完成”按钮。因此无法保证页面回跳时，支付流程已结束，所以商户设置的redirect_url地址不能自动执行查单操作，应让用户去点击按钮触发查单操作。 本博客参考 ：https://blog.csdn.net/vbirdbest/article/details/80726616 原创文档","tags":[{"name":"H5微信支付","slug":"H5微信支付","permalink":"https://whalesfalling.github.io/tags/H5微信支付/"}]},{"title":"IDEA SPringBoot Mybatis 整合","date":"2019-03-18T02:58:55.000Z","path":"2019/03/18/IDEA-Spring-boot-Mybatis.html","text":"前言​ 本次将整合springboot 2.0+版本 + Mybatis，由于springboot 2.0之下的版本需要很多繁琐的配置，所以本次直接集成2.0版本。 项目架构​ ~ 开发工具：Intellig IDEA 2017 ​ ~ maven：3.3.9 ​ ~ JDK版本 ：至少1.8及以上； ​ ~ springboot版本：2.0.1RELEASE； ​ ~ thymeleaf; ​ ~ mybatis; 额外功能​ ~ PageHelper 分页插件； ​ ~ mybatis generator 自动生成代码插件； ​ ~ logback 日志; 写在前面​ 网络上有很多关于集成spring boot框架的，但是都不怎么全面，本次将整合一个完整版可以直接用于开发的spring boot框架，废话不多说，直接上代码： 开始搭建：创建项目：1. 创建一个spring boot项目 2. 创建项目的文件结构以及jdk的版本 3. 选择项目所需要的依赖 然后点击finish; 4. 文件目录结构如下： 5. 查看下pom.xml1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 ?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.mypro&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 6. 项目使用application.yml , 需要将原本的application.properties删除 ， 新建更为简洁的application.yml文件1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 server: port: 8088 spring: #激活哪一个环境的配置文件 #公共配置 profiles: active: dev # pro为生产环境 dev为开发环境 jackson: date-format: yyyy-MM-dd HH:mm:ss datasource: name: mysql_test type: com.alibaba.druid.pool.DruidDataSource #druid相关配置 druid: #监控统计拦截的filters filters: stat driver-class-name: com.mysql.cj.jdbc.Driver #基本属性 url: jdbc:mysql://127.0.0.1:3306/winter?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: root password: luotao@1234 #配置初始化大小/最小/最大 initial-size: 1 min-idle: 1 max-active: 20 #获取连接等待超时时间 max-wait: 60000 #间隔多久进行一次检测，检测需要关闭的空闲连接 time-between-eviction-runs-millis: 60000 #一个连接在池中最小生存的时间 min-evictable-idle-time-millis: 300000 validation-query: SELECT &apos;x&apos; test-while-idle: true test-on-borrow: false test-on-return: false #打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false pool-prepared-statements: false max-pool-prepared-statement-per-connection-size: 20 7. 创建数据库1 2 3 4 5 6 7 8 CREATE DATABASE winter; CREATE TABLE db_user( user_id INT NOT NULL PRIMATY KEY AUTO_INCREMENT, user_name VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, phone VARCHAR(255) NOT NULL ) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf-8; 8. 使用mybatis generator 自动生成代码​ ~ 配置pom.xml中generator插件对应配置，新建generatorConfig.xml文件，位置在resource/generator/generatorConfig.xml： pom.xml: 1 2 3 4 5 6 7 8 9 10 11 &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; generatorConfig.xml： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location=\"E:\\developer\\mybatis-generator-core-1.3.2\\lib\\mysql-connector-java-5.1.25-bin.jar\"/&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1/mytest\" userId=\"root\" password=\"root\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=\"com.mypro.springbootmybatis.model\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapping\" targetProject=\"src/main/resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.mypro.springbootmybatis.dao\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=\"t_user\" domainObjectName=\"User\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 9. 点击 Run Configurations… 10. 添加配置 11. 运行 （一张表不能多次运行，不然映射文件会出现多次代码导致报错） ​ 文件及目录结构： 12. 生成的文件UserDao.java 1 2 3 4 5 6 7 8 9 10 11 12 import org.apache.ibatis.annotations.Mapper; import java.util.List; @Mapper public interface UserDao &#123; int insert(User record); // 这个是自己新增的 List&lt;User&gt; selectUsers(); &#125; User.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class User &#123; private Integer userId; private String userName; private String password; private String phone; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; &#125; UserMapper.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt; &lt;mapper namespace=\"com.mypro.springbootmybatis.dao.UserDao\" &gt; &lt;sql id=\"BASE_TABLE\"&gt; db_user &lt;/sql&gt; &lt;sql id=\"BASE_COLUMN\"&gt; userId,userName,password,phone &lt;/sql&gt; &lt;insert id=\"insert\" parameterType=\"com.mypro.springbootmybatis.model.User\"&gt; INSERT INTO &lt;include refid=\"BASE_TABLE\"/&gt; &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"&gt; userName,password, &lt;if test=\"phone != null\"&gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"VALUES(\" suffix=\")\" suffixOverrides=\",\"&gt; #&#123;userName, jdbcType=VARCHAR&#125;,#&#123;password, jdbcType=VARCHAR&#125;, &lt;if test=\"phone != null\"&gt; #&#123;phone, jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;select id=\"selectUsers\" resultType=\"com.mypro.springbootmybatis.model.User\"&gt; SELECT &lt;include refid=\"BASE_COLUMN\"/&gt; FROM &lt;include refid=\"BASE_TABLE\"/&gt; &lt;/select&gt; &lt;/mapper&gt; 13. 打开启动类SpringbootmybatisApplication.java 1 2 3 4 5 6 7 8 9 10 11 12 13 import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\"com.mypro.springbootmybatis.dao\")//将项目中对应的mapper类的路径加进来就可以了 public class SpringbootmybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootmybatisApplication.class, args); &#125; &#125; 查看现在的目录结构 Controller,service层的代码都写好了： UserController.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; @Controller @RequestMapping(value = \"/user\") public class UserController &#123; @Autowired private UserService userService; /** * 功能描述: 新增用户 * @param: [user] * @return: int * @auther: T-luot * @date: 2019/3/12 20:44 */ @ResponseBody @PostMapping(\"/add\") public int addUser(User user)&#123; return userService.addUser(user); &#125; /** * 功能描述: 查询所有用户 * @param: [pageNum, pageSize] * @return: java.lang.Object * @auther: T-luot * @date: 2019/3/12 20:44 */ @ResponseBody @GetMapping(\"/all\") public Object findAllUser( @RequestParam(name = \"pageNum\", required = false, defaultValue = \"1\") int pageNum, @RequestParam(name = \"pageSize\", required = false, defaultValue = \"10\") int pageSize)&#123; return userService.findAllUser(pageNum,pageSize); &#125; &#125; UserService.java 1 2 3 4 5 6 7 8 9 /** * Created by Administrator on 2018/4/19. */ public interface UserService &#123; int addUser(User user); PageInfo&lt;User&gt; findAllUser(int pageNum, int pageSize); &#125; UserServiceImpl.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * Created by Administrator on 2017/8/16. */ @Service(value = \"UserService\") public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao;//这里会报错，但是并不会影响 @Override public int addUser(User user) &#123; return userDao.insert(user); &#125; /* * 这个方法中用到了我们开头配置依赖的分页插件pagehelper * 很简单，只需要在service层传入参数，然后将参数传递给一个插件的一个静态方法即可； * pageNum 开始页数 * pageSize 每页显示的数据条数 * */ @Override public PageInfo&lt;User&gt; findAllUser(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 PageHelper.startPage(pageNum, pageSize); List&lt;User&gt; userDomains = userDao.selectUsers(); PageInfo result = new PageInfo(userDomains); return result; &#125; application.yml新增分页信息 1 2 3 4 5 6 7 8 9 10 11 12 ## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别 mybatis: mapper-locations: classpath:mapper/*.xml #注意：一定要对应mapper映射xml文件的所在路径 type-aliases-package: com.mypro.springbootmybatis.model # 注意：对应实体类的路径 #pagehelper pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql returnPageInfo: check 13. 测试，测试这里没有使用junit4了，使用的是postman这款工具 百度上有安装包，一路Next下去就好，记得切换安装地址，不要装在C盘 返回的结果如下： 看下pow.xml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 14. 配置日志resourcem目录下新建logback-spring.xml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;configuration scan=\"true\" scanPeriod=\"10 seconds\"&gt; &lt;!--&lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt;--&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=\"log.path\" value=\"D:/log/winter\" /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\" /&gt; &lt;conversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\" /&gt; &lt;conversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\" /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=\"CONSOLE_LOG_PATTERN\" value=\"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;\"/&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt; &lt;appender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_debug.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 日志归档 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/debug/log-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录debug级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=\"ERROR_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、 以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前logger将会继承上级的级别。 addtivity:是否向上级logger传递打印信息。默认是true。 --&gt; &lt;!--&lt;logger name=\"org.springframework.web\" level=\"info\"/&gt;--&gt; &lt;!--&lt;logger name=\"org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor\" level=\"INFO\"/&gt;--&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=\"info\"&gt;改成&lt;root level=\"DEBUG\"&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别： --&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 不能设置为INHERITED或者同义词NULL。默认是DEBUG 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.winter\"/&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"DEBUG_FILE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;appender-ref ref=\"WARN_FILE\" /&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=\"pro\"&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"DEBUG_FILE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;appender-ref ref=\"WARN_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;/configuration&gt; application.yml最终版： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 server: port: 8088 spring: #激活哪一个环境的配置文件 #公共配置 profiles: active: dev # pro为生产环境 dev为开发环境 jackson: date-format: yyyy-MM-dd HH:mm:ss datasource: name: mysql_test type: com.alibaba.druid.pool.DruidDataSource #druid相关配置 druid: #监控统计拦截的filters filters: stat driver-class-name: com.mysql.cj.jdbc.Driver #基本属性 url: jdbc:mysql://127.0.0.1:3306/winter?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: root password: luotao@1234 #配置初始化大小/最小/最大 initial-size: 1 min-idle: 1 max-active: 20 #获取连接等待超时时间 max-wait: 60000 #间隔多久进行一次检测，检测需要关闭的空闲连接 time-between-eviction-runs-millis: 60000 #一个连接在池中最小生存的时间 min-evictable-idle-time-millis: 300000 validation-query: SELECT &apos;x&apos; test-while-idle: true test-on-borrow: false test-on-return: false #打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false pool-prepared-statements: false max-pool-prepared-statement-per-connection-size: 20 ## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别 mybatis: mapper-locations: classpath:mapper/*.xml #注意：一定要对应mapper映射xml文件的所在路径 type-aliases-package: com.mypro.springbootmybatis.model # 注意：对应实体类的路径 #pagehelper pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql returnPageInfo: check logging: config: classpath:logback-spring.xml pom.xml最终版： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;mypro.springbootmybatis&lt;/groupId&gt; &lt;artifactId&gt;springbootmybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootmybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 如此IDEA集成spring boot+myBatis就已经完成了。 源码地址：https://github.com/whalesfalling/springboot-mybatis-demo","tags":[{"name":"SPringBoot整合","slug":"SPringBoot整合","permalink":"https://whalesfalling.github.io/tags/SPringBoot整合/"}]}]