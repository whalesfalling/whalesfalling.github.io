[{"title":"并发编程-synchronized关键字的使用","date":"2019-03-31T07:34:35.000Z","path":"2019/03/31/use-synchronized.html","text":"前言​ 在工作中，我们经常会使用到并发编程，synchronized，volatile，ReentranLock，concurrent这几个关键字下的包相信大部分程序员都听说过，这些看似高深的代名词，很多人都不懂得如何去使用，滥用的结果往往都需要自己承担后果。在本章中，为大家讲解 synchronized 关键字的使用。 描述​ 我看过许多关于线程安全方面的书籍，上面对线程安全描述的很笼统，最近在一本老外写的书上，看到对线程安全的很形象描述： 线程安全的概念：当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 sysnchronized: 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。 代码示例12345678public class MyThread extends Thread&#123; private int count = 5; // synchronized加锁 public synchronized void run()&#123; count--; System.out.println(this.currentThread().getName() + \" count = \" + count); &#125;&#125; ​ 我们来读一下这段代码，首先我新建了一个名为 MyThread 的类，并且让这个类继承了 Thread ，在这个类中定义了一个私有变量 count ，初始值为5，定义了一个 run() 方法，在这个方法里面对 count 进行了 – 操作,然后输出线程的名称和 count 的值。 ​ 我们用一个 main 方法来测试一下这个类： 12345678910111213 public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread,\"t1\"); Thread t2 = new Thread(myThread,\"t2\"); Thread t3 = new Thread(myThread,\"t3\"); Thread t4 = new Thread(myThread,\"t4\"); Thread t5 = new Thread(myThread,\"t5\"); t1.start(); t2.start(); t3.start(); t4.start(); t5.start();&#125; ​ 输出结果如下： 12345t3 count = 2t5 count = 0t2 count = 1t1 count = 1t4 count = 1 ​ 这个结果和我们预期输出的结果是不相符的，我们称它为 非线程安全 的，所以我们在 run() 方法上加上 synchronized 关键字，我们再来看下输出的结果： 12345678public class MyThread extends Thread&#123; private int count = 5; // synchronized加锁 public synchronized void run()&#123; count--; System.out.println(this.currentThread().getName() + \" count = \" + count); &#125;&#125; ​ 输出结果如下，我们称它为 线程安全 的： 12345t1 count = 4t5 count = 3t4 count = 2t3 count = 1t2 count = 0 结果分析 ​ 当多个线程访问 MyThread 的 run() 方法时，会以排队的方式进行处理（这里排队的方式是指CPU分配的先后顺序而定的），一个线程想要执行 synchronized 关键字修饰的方法里的代码： 尝试获得锁； 如果拿到锁，执行 synchronized 代码块里的内容；拿不到锁，会去不断尝试获取这把锁，直到拿到锁为止，而且时多个线程同时去竞争这把锁（也就是会出现 锁竞争 问题）。 备注锁竞争：即1000个或1000个以上的线程同时访问同一个线程，其中第一个获得后，其他的999个线程同时去竞争第一个调用完成后释放的锁，造成CPU的使用率特别高，系统出现卡顿，宕机的问题，一般出现在大型企业系统中，后面会讲到如何去解决这个问题。","tags":[{"name":"synchronized","slug":"synchronized","permalink":"http://whalesfalling.github.io/tags/synchronized/"}]},{"title":"IDEA SPringBoot 整合H5微信支付","date":"2019-03-25T02:00:54.000Z","path":"2019/03/25/IDEA-SPringBoot-H5WXZF.html","text":"前言​ 上周由于项目需要开通H5微信支付功能，于是在网上参考了很多例子，由于数据缺失，实用性不高，所以在此特地将SpringBoot整合H5微信支付的流程整理成文档，测试可用。 场景介绍​ H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。 ​ 主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付。 ​ 申请入口：登录商户平台–&gt;产品中心–&gt;我的产品–&gt;支付产品–&gt;H5支付 ​ 注意：需要开通H5支付，并且做一些配置 ​ 微信官方体验链接：https://wxpay.wxutil.com/mch/pay/h5.v2.php，请在微信外浏览器打开。 1、用户在商户侧完成下单，使用微信支付进行支付 2、由商户后台向微信支付发起下单请求（调用统一下单接口）注：交易类型trade_type=MWEB 3、统一下单接口返回支付相关参数给商户后台，如支付跳转url（参数名“mweb_url”），商户通过mweb_url调起微信支付中间页 4、中间页进行H5权限的校验，安全性检查（此处常见错误请见下文） 5、如支付成功，商户后台会接收到微信侧的异步通知 6、用户在微信支付收银台完成支付或取消支付,返回商户页面（默认为返回支付发起页面） 7、商户在展示页面，引导用户主动发起支付结果的查询 8、商户后台判断是否接到收微信侧的支付结果通知，如没有，后台调用我们的订单查询接口确认订单状态 9、展示最终的订单支付结果给用户 H5支付文档 集成H5微信支付1.导入依赖jar包1234567891011&lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 2. application.yml12345678910111213141516# 测试账号pay: wxpay: appID: wxab8acb865bb1637e mchID: 11473623 key: 2ab9071b06b9f739b950ddb41db2690d sandboxKey: 3639bc1370e105aa65f10cd4fef2a3ef certPath: /var/local/cert/apiclient_cert.p12 notifyUrl: http://65ta5j.natappfree.cc/wxpay/refund/notify useSandbox: truespring: thymeleaf: prefix: classpath:/templates/ suffix: .html mode: HTML5 encoding: UTF-8 3. WebMvcConfiguration123456789101112131415161718@Configurationpublic class WebMvcConfiguration extends WebMvcConfigurationSupport &#123; @Override protected void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/gotoWapPage\").setViewName(\"gotoWapPay\"); registry.addViewController(\"/gotoPagePage\").setViewName(\"gotoPagePay\"); registry.addViewController(\"/gotoH5Page\").setViewName(\"gotoH5Page\"); registry.addViewController(\"/h5PaySuccess\").setViewName(\"h5PaySuccess\"); super.addViewControllers(registry); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); super.addResourceHandlers(registry); &#125;&#125; 4. MyWXPayConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 微信支付的参数配置 * * @author mengday zhang */@Data@Slf4j@ConfigurationProperties(prefix = \"pay.wxpay\")public class MyWXPayConfig implements WXPayConfig&#123; /** 公众账号ID */ private String appID; /** 商户号 */ private String mchID; /** API 密钥 */ private String key; /** API 沙箱环境密钥 */ private String sandboxKey; /** API证书绝对路径 */ private String certPath; /** 退款异步通知地址 */ private String notifyUrl; private Boolean useSandbox; /** HTTP(S) 连接超时时间，单位毫秒 */ private int httpConnectTimeoutMs = 8000; /** HTTP(S) 读数据超时时间，单位毫秒 */ private int httpReadTimeoutMs = 10000; /** * 获取商户证书内容 * * @return 商户证书内容 */ @Override public InputStream getCertStream() &#123; File certFile = new File(certPath); InputStream inputStream = null; try &#123; inputStream = new FileInputStream(certFile); &#125; catch (FileNotFoundException e) &#123; log.error(\"cert file not found, path=&#123;&#125;, exception is:&#123;&#125;\", certPath, e); &#125; return inputStream; &#125; @Override public String getKey()&#123; if (useSandbox) &#123; return sandboxKey; &#125; return key; &#125;&#125; 5. WXPayClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * WXPayClient * &lt;p&gt; * 对WXPay的简单封装，处理支付密切相关的逻辑. * * @author Mengday Zhang * @version 1.0 * @since 2018/6/16 */@Slf4jpublic class WXPayClient extends WXPay &#123; /** 密钥算法 */ private static final String ALGORITHM = \"AES\"; /** 加解密算法/工作模式/填充方式 */ private static final String ALGORITHM_MODE_PADDING = \"AES/ECB/PKCS5Padding\"; /** 用户支付中，需要输入密码 */ private static final String ERR_CODE_USERPAYING = \"USERPAYING\"; private static final String ERR_CODE_AUTHCODEEXPIRE = \"AUTHCODEEXPIRE\"; /** 交易状态: 未支付 */ private static final String TRADE_STATE_NOTPAY = \"NOTPAY\"; /** 用户输入密码，尝试30秒内去查询支付结果 */ private static Integer remainingTimeMs = 10000; private WXPayConfig config; public WXPayClient(WXPayConfig config, WXPayConstants.SignType signType, boolean useSandbox) &#123; super(config, signType, useSandbox); this.config = config; &#125; /** * * 刷卡支付 * * 对WXPay#microPay(Map)增加了当支付结果为USERPAYING时去轮询查询支付结果的逻辑处理 * * 注意：该方法没有处理return_code=FAIL的情况，暂时不考虑网络问题，这种情况直接返回错误 * * @param reqData * @return * @throws Exception */ public Map&lt;String, String&gt; microPayWithPOS(Map&lt;String, String&gt; reqData) throws Exception &#123; // 开始时间(毫秒) long startTimestampMs = System.currentTimeMillis(); Map&lt;String, String&gt; responseMapForPay = super.microPay(reqData); log.info(responseMapForPay.toString()); // // 先判断 协议字段返回(return_code)，再判断 业务返回，最后判断 交易状态(trade_state) // 通信标识，非交易标识 String returnCode = responseMapForPay.get(\"return_code\"); if (WXPayConstants.SUCCESS.equals(returnCode)) &#123; String errCode = responseMapForPay.get(\"err_code\"); // 余额不足，信用卡失效 if (ERR_CODE_USERPAYING.equals(errCode) || \"SYSTEMERROR\".equals(errCode) || \"BANKERROR\".equals(errCode)) &#123; Map&lt;String, String&gt; orderQueryMap = null; Map&lt;String, String&gt; requestData = new HashMap&lt;&gt;(); requestData.put(\"out_trade_no\", reqData.get(\"out_trade_no\")); // 用户支付中，需要输入密码或系统错误则去重新查询订单API err_code, result_code, err_code_des // 每次循环时的当前系统时间 - 开始时记录的时间 &gt; 设定的30秒时间就退出 while (System.currentTimeMillis() - startTimestampMs &lt; remainingTimeMs) &#123; // 商户收银台得到USERPAYING状态后，经过商户后台系统调用【查询订单API】查询实际支付结果。 orderQueryMap = super.orderQuery(requestData); String returnCodeForQuery = orderQueryMap.get(\"return_code\"); if (WXPayConstants.SUCCESS.equals(returnCodeForQuery)) &#123; // 通讯成功 String tradeState = orderQueryMap.get(\"trade_state\"); if (WXPayConstants.SUCCESS.equals(tradeState)) &#123; // 如果成功了直接将查询结果返回 return orderQueryMap; &#125; // 如果支付结果仍为USERPAYING，则每隔5秒循环调用【查询订单API】判断实际支付结果 Thread.sleep(1000); &#125; &#125; // 如果用户取消支付或累计30秒用户都未支付，商户收银台退出查询流程后继续调用【撤销订单API】撤销支付交易。 String tradeState = orderQueryMap.get(\"trade_state\"); if (TRADE_STATE_NOTPAY.equals(tradeState) || ERR_CODE_USERPAYING.equals(tradeState) || ERR_CODE_AUTHCODEEXPIRE.equals(tradeState)) &#123; Map&lt;String, String&gt; reverseMap = this.reverse(requestData); String returnCodeForReverse = reverseMap.get(\"return_code\"); String resultCode = reverseMap.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCodeForReverse) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; // 如果撤销成功，需要告诉客户端已经撤销订单了 responseMapForPay.put(\"err_code_des\", \"用户取消支付或尚未支付，后台已经撤销该订单，请重新支付！\"); &#125; &#125; &#125; &#125; return responseMapForPay; &#125; /** * 从request的inputStream中获取参数 * @param request * @return * @throws Exception */ public Map&lt;String, String&gt; getNotifyParameter(HttpServletRequest request) throws Exception &#123; InputStream inputStream = request.getInputStream(); ByteArrayOutputStream outSteam = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) &#123; outSteam.write(buffer, 0, length); &#125; outSteam.close(); inputStream.close(); // 获取微信调用我们notify_url的返回信息 String resultXml = new String(outSteam.toByteArray(), \"utf-8\"); Map&lt;String, String&gt; notifyMap = WXPayUtil.xmlToMap(resultXml); return notifyMap; &#125; /** * 解密退款通知 * * &lt;a href=\"https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_16&amp;index=11&gt;退款结果通知文档&lt;/a&gt; * @return * @throws Exception */ public Map&lt;String, String&gt; decodeRefundNotify(HttpServletRequest request) throws Exception &#123; // 从request的流中获取参数 Map&lt;String, String&gt; notifyMap = this.getNotifyParameter(request); log.info(notifyMap.toString()); String reqInfo = notifyMap.get(\"req_info\"); //（1）对加密串A做base64解码，得到加密串B byte[] bytes = new BASE64Decoder().decodeBuffer(reqInfo); //（2）对商户key做md5，得到32位小写key* ( key设置路径：微信商户平台(pay.weixin.qq.com)--&gt;账户设置--&gt;API安全--&gt;密钥设置 ) Cipher cipher = Cipher.getInstance(ALGORITHM_MODE_PADDING); SecretKeySpec key = new SecretKeySpec(WXPayUtil.MD5(config.getKey()).toLowerCase().getBytes(), ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); //（3）用key*对加密串B做AES-256-ECB解密（PKCS7Padding） // java.security.InvalidKeyException: Illegal key size or default parameters // https://www.cnblogs.com/yaks/p/5608358.html String responseXml = new String(cipher.doFinal(bytes),\"UTF-8\"); Map&lt;String, String&gt; responseMap = WXPayUtil.xmlToMap(responseXml); return responseMap; &#125; /** * 获取沙箱环境验签秘钥API * &lt;a href=\"https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=23_1\"&gt;获取验签秘钥API文档&lt;/a&gt; * @return * @throws Exception */ public Map&lt;String, String&gt; getSignKey() throws Exception &#123; Map&lt;String, String&gt; reqData = new HashMap&lt;&gt;(); reqData.put(\"mch_id\", config.getMchID()); reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr()); String sign = WXPayUtil.generateSignature(reqData, config.getKey(), WXPayConstants.SignType.MD5); reqData.put(\"sign\", sign); String responseXml = this.requestWithoutCert(\"https://api.mch.weixin.qq.com/sandboxnew/pay/getsignkey\", reqData, config.getHttpConnectTimeoutMs(), config.getHttpReadTimeoutMs()); Map&lt;String, String&gt; responseMap = WXPayUtil.xmlToMap(responseXml); return responseMap; &#125;&#125; 6. WXPayConfiguration1234567891011121314151617181920212223242526/** * 微信支付配置 * * @author mengday zhang */@Configuration@EnableConfigurationProperties(MyWXPayConfig.class)public class WXPayConfiguration &#123; @Autowired private MyWXPayConfig wxPayConfig; /** * useSandbox 沙盒环境 * @return */ @Bean public WXPay wxPay() &#123; return new WXPay(wxPayConfig, WXPayConstants.SignType.MD5, wxPayConfig.getUseSandbox() ); &#125; @Bean public WXPayClient wxPayClient() &#123; return new WXPayClient(wxPayConfig, WXPayConstants.SignType.MD5, wxPayConfig.getUseSandbox()); &#125;&#125; 7. gotoH5Page.html12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body style=\"font-size: 30px\"&gt;&lt;h3&gt;购买商品：可口可乐&lt;/h3&gt;&lt;h3&gt;价格：4&lt;/h3&gt;&lt;h3&gt;数量：10个&lt;/h3&gt;&lt;button style=\"width: 100%; height: 60px; alignment: center; background: #b49e8f\" onclick=\"commitOrder()\"&gt;提交订单&lt;/button&gt;&lt;script src=\"http://localhost:8080/webjars/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; function commitOrder() &#123; $.ajax(&#123; type: \"POST\", url: \"http://localhost:8080/wxpay/h5pay/order\", data: null, success: function(data) &#123; console.log(data); var redirectUrl = \"http://localhost:8080/h5PaySuccess\"; var mwebUrl = data.mweb_url+\"&amp;redirect_url=\"+encodeURIComponent(redirectUrl); window.location.href=mwebUrl; &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8. h5PaySuccess.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;微信支付-H5支付成功&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 9. WXPayH5PayController1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 微信支付-H5支付. * &lt;p&gt; * detailed description * * @author Mengday Zhang * @version 1.0 * @since 2018/6/18 */@Slf4j@RestController@RequestMapping(\"/wxpay/h5pay\")public class WXPayH5PayController &#123; @Autowired private WXPay wxPay; @Autowired private WXPayClient wxPayClient; /** * 使用沙箱支付的金额必须是用例中指定的金额，也就是 1.01 元，1.02元等，不能是你自己的商品的实际价格，必须是这个数。 * 否则会报错：沙箱支付金额(2000)无效，请检查需要验收的case * @return * @throws Exception */ @PostMapping(\"/order\") public Object h5pay() throws Exception &#123; Map&lt;String, String&gt; reqData = new HashMap&lt;&gt;(); reqData.put(\"out_trade_no\", String.valueOf(System.nanoTime())); reqData.put(\"trade_type\", \"MWEB\"); reqData.put(\"product_id\", \"1\"); reqData.put(\"body\", \"商户下单\"); // 订单总金额，单位为分 reqData.put(\"total_fee\", \"101\"); // APP和网页支付提交用户端ip，Native支付填调用微信支付API的机器IP。 reqData.put(\"spbill_create_ip\", \"14.23.150.211\"); // 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。 reqData.put(\"notify_url\", \"http://3sbqi7.natappfree.cc/wxpay/h5pay/notify\"); // 自定义参数, 可以为终端设备号(门店号或收银设备ID)，PC网页或公众号内支付可以传\"WEB\" reqData.put(\"device_info\", \"\"); // 附加数据，在查询API和支付通知中原样返回，可作为自定义参数使用。 reqData.put(\"attach\", \"\"); reqData.put(\"scene_info\", \"&#123;\\\"h5_info\\\": &#123;\\\"type\\\":\\\"Wap\\\",\\\"wap_url\\\": \\\"http://3sbqi7.natappfree.cc\\\",\\\"wap_name\\\": \\\"腾讯充值\\\"&#125;&#125;\"); Map&lt;String, String&gt; responseMap = wxPay.unifiedOrder(reqData); log.info(responseMap.toString()); String returnCode = responseMap.get(\"return_code\"); String resultCode = responseMap.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCode) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; // 预支付交易会话标识 String prepayId = responseMap.get(\"prepay_id\"); // 支付跳转链接(前端需要在该地址上拼接redirect_url,该参数不是必须的) // 正常流程用户支付完成后会返回至发起支付的页面，如需返回至指定页面，则可以在MWEB_URL后拼接上redirect_url参数，来指定回调页面 // 需对redirect_url进行urlencode处理 // TODO 正常情况下这里应该是普通的链接，不知道这里为何是weixin://这样的链接，不知道是不是微信公众平台上的配置少配置了； // 由于没有实际账号，还没找到为啥不是普通链接的原因 String mwebUrl = responseMap.get(\"mweb_url\"); &#125; return responseMap; &#125; /** * 注意：如果是沙箱环境，一提交订单就会立即异步通知，而无需拉起微信支付收银台的中间页面 * @param request * @throws Exception */ @RequestMapping(\"/notify\") public void payNotify(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; Map&lt;String, String&gt; reqData = wxPayClient.getNotifyParameter(request); log.info(reqData.toString()); String returnCode = reqData.get(\"return_code\"); String resultCode = reqData.get(\"result_code\"); if (WXPayConstants.SUCCESS.equals(returnCode) &amp;&amp; WXPayConstants.SUCCESS.equals(resultCode)) &#123; boolean signatureValid = wxPay.isPayResultNotifySignatureValid(reqData); if (signatureValid) &#123; // TODO 业务处理 Map&lt;String, String&gt; responseMap = new HashMap&lt;&gt;(2); responseMap.put(\"return_code\", \"SUCCESS\"); responseMap.put(\"return_msg\", \"OK\"); String responseXml = WXPayUtil.mapToXml(responseMap); response.setContentType(\"text/xml\"); response.getWriter().write(responseXml); response.flushBuffer(); &#125; &#125; &#125;&#125; 常见问题1.@Data @Slf4j标签的引用 参考 IntelliJ IDEA lombok插件的安装和使用 2.微信支付常见错误 参考 微信官方文档 微信支付常见问题 微信返回错误提示 3.沙箱环境说明 参考 浅析微信支付：如何使用沙箱环境测试 注意：本文档中 useSandbox: true 为沙箱测试环境，返回微信地址为 weixin://这样的链接，提交订单就会立即异步通知，不会拉起微信支付收银台的中间页面，当 useSandbox: false 时，切换为生产环境，浏览器会跳转至微信支付收银台的中间页面。 回调页面​ 正常流程用户支付完成后会返回至发起支付的页面，如需返回至指定页面，则可以在MWEB_URL后拼接上redirect_url参数，来指定回调页面。 如： ​ 您希望用户支付完成后跳转至https://www.wechatpay.com.cn，则可以做如下处理： ​ 假设您通过统一下单接口获到的MWEB_URL= https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx20161110163838f231619da20804912345&amp;package=1037687096 ​ 则拼接后的地址为MWEB_URL= https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx20161110163838f231619da20804912345&amp;package=1037687096&amp;redirect_url=https%3A%2F%2Fwww.wechatpay.com.cn 注意： 注意MWEB_URL是普通的链接，不是微信weixin://短链接（useSandbox: false）需对redirect_url进行urlencode处理由于设置redirect_url后,回跳指定页面的操作可能发生在： 微信支付中间页调起微信收银台后超过5秒 用户点击“取消支付“或支付完成后点“完成”按钮。因此无法保证页面回跳时，支付流程已结束，所以商户设置的redirect_url地址不能自动执行查单操作，应让用户去点击按钮触发查单操作。 本博客参考 ：https://blog.csdn.net/vbirdbest/article/details/80726616 原创文档","tags":[{"name":"H5微信支付","slug":"H5微信支付","permalink":"http://whalesfalling.github.io/tags/H5微信支付/"}]},{"title":"IDEA SPringBoot Mybatis 整合","date":"2019-03-18T02:58:55.000Z","path":"2019/03/18/IDEA-Spring-boot-Mybatis.html","text":"前言​ 本次将整合springboot 2.0+版本 + Mybatis，由于springboot 2.0之下的版本需要很多繁琐的配置，所以本次直接集成2.0版本。 项目架构​ ~ 开发工具：Intellig IDEA 2017 ​ ~ maven：3.3.9 ​ ~ JDK版本 ：至少1.8及以上； ​ ~ springboot版本：2.0.1RELEASE； ​ ~ thymeleaf; ​ ~ mybatis; 额外功能​ ~ PageHelper 分页插件； ​ ~ mybatis generator 自动生成代码插件； ​ ~ logback 日志; 写在前面​ 网络上有很多关于集成spring boot框架的，但是都不怎么全面，本次将整合一个完整版可以直接用于开发的spring boot框架，废话不多说，直接上代码： 开始搭建：创建项目：1. 创建一个spring boot项目 2. 创建项目的文件结构以及jdk的版本 3. 选择项目所需要的依赖 然后点击finish; 4. 文件目录结构如下： 5. 查看下pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.mypro&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6. 项目使用application.yml , 需要将原本的application.properties删除 ， 新建更为简洁的application.yml文件12345678910111213141516171819202122232425262728293031323334353637383940server: port: 8088spring:#激活哪一个环境的配置文件#公共配置 profiles: active: dev # pro为生产环境 dev为开发环境 jackson: date-format: yyyy-MM-dd HH:mm:ss datasource: name: mysql_test type: com.alibaba.druid.pool.DruidDataSource #druid相关配置 druid: #监控统计拦截的filters filters: stat driver-class-name: com.mysql.cj.jdbc.Driver #基本属性 url: jdbc:mysql://127.0.0.1:3306/winter?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: root password: luotao@1234 #配置初始化大小/最小/最大 initial-size: 1 min-idle: 1 max-active: 20 #获取连接等待超时时间 max-wait: 60000 #间隔多久进行一次检测，检测需要关闭的空闲连接 time-between-eviction-runs-millis: 60000 #一个连接在池中最小生存的时间 min-evictable-idle-time-millis: 300000 validation-query: SELECT &apos;x&apos; test-while-idle: true test-on-borrow: false test-on-return: false #打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false pool-prepared-statements: false max-pool-prepared-statement-per-connection-size: 20 7. 创建数据库12345678CREATE DATABASE winter;CREATE TABLE db_user( user_id INT NOT NULL PRIMATY KEY AUTO_INCREMENT, user_name VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, phone VARCHAR(255) NOT NULL) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf-8; 8. 使用mybatis generator 自动生成代码​ ~ 配置pom.xml中generator插件对应配置，新建generatorConfig.xml文件，位置在resource/generator/generatorConfig.xml： pom.xml: 1234567891011&lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; generatorConfig.xml： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location=\"E:\\developer\\mybatis-generator-core-1.3.2\\lib\\mysql-connector-java-5.1.25-bin.jar\"/&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1/mytest\" userId=\"root\" password=\"root\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=\"com.mypro.springbootmybatis.model\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapping\" targetProject=\"src/main/resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.mypro.springbootmybatis.dao\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=\"t_user\" domainObjectName=\"User\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 9. 点击 Run Configurations… 10. 添加配置 11. 运行 （一张表不能多次运行，不然映射文件会出现多次代码导致报错） ​ 文件及目录结构： 12. 生成的文件UserDao.java 123456789101112import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface UserDao &#123; int insert(User record); // 这个是自己新增的 List&lt;User&gt; selectUsers();&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class User &#123; private Integer userId; private String userName; private String password; private String phone; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.mypro.springbootmybatis.dao.UserDao\" &gt; &lt;sql id=\"BASE_TABLE\"&gt; db_user &lt;/sql&gt; &lt;sql id=\"BASE_COLUMN\"&gt; userId,userName,password,phone &lt;/sql&gt; &lt;insert id=\"insert\" parameterType=\"com.mypro.springbootmybatis.model.User\"&gt; INSERT INTO &lt;include refid=\"BASE_TABLE\"/&gt; &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"&gt; userName,password, &lt;if test=\"phone != null\"&gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"VALUES(\" suffix=\")\" suffixOverrides=\",\"&gt; #&#123;userName, jdbcType=VARCHAR&#125;,#&#123;password, jdbcType=VARCHAR&#125;, &lt;if test=\"phone != null\"&gt; #&#123;phone, jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;select id=\"selectUsers\" resultType=\"com.mypro.springbootmybatis.model.User\"&gt; SELECT &lt;include refid=\"BASE_COLUMN\"/&gt; FROM &lt;include refid=\"BASE_TABLE\"/&gt; &lt;/select&gt;&lt;/mapper&gt; 13. 打开启动类SpringbootmybatisApplication.java 12345678910111213import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(\"com.mypro.springbootmybatis.dao\")//将项目中对应的mapper类的路径加进来就可以了public class SpringbootmybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootmybatisApplication.class, args); &#125;&#125; 查看现在的目录结构 Controller,service层的代码都写好了： UserController.java 1234567891011121314151617181920212223242526272829303132333435363738394041import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@Controller@RequestMapping(value = \"/user\")public class UserController &#123; @Autowired private UserService userService; /** * 功能描述: 新增用户 * @param: [user] * @return: int * @auther: T-luot * @date: 2019/3/12 20:44 */ @ResponseBody @PostMapping(\"/add\") public int addUser(User user)&#123; return userService.addUser(user); &#125; /** * 功能描述: 查询所有用户 * @param: [pageNum, pageSize] * @return: java.lang.Object * @auther: T-luot * @date: 2019/3/12 20:44 */ @ResponseBody @GetMapping(\"/all\") public Object findAllUser( @RequestParam(name = \"pageNum\", required = false, defaultValue = \"1\") int pageNum, @RequestParam(name = \"pageSize\", required = false, defaultValue = \"10\") int pageSize)&#123; return userService.findAllUser(pageNum,pageSize); &#125;&#125; UserService.java 123456789/** * Created by Administrator on 2018/4/19. */public interface UserService &#123; int addUser(User user); PageInfo&lt;User&gt; findAllUser(int pageNum, int pageSize);&#125; UserServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * Created by Administrator on 2017/8/16. */@Service(value = \"UserService\")public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao;//这里会报错，但是并不会影响 @Override public int addUser(User user) &#123; return userDao.insert(user); &#125; /* * 这个方法中用到了我们开头配置依赖的分页插件pagehelper * 很简单，只需要在service层传入参数，然后将参数传递给一个插件的一个静态方法即可； * pageNum 开始页数 * pageSize 每页显示的数据条数 * */ @Override public PageInfo&lt;User&gt; findAllUser(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 PageHelper.startPage(pageNum, pageSize); List&lt;User&gt; userDomains = userDao.selectUsers(); PageInfo result = new PageInfo(userDomains); return result; &#125; application.yml新增分页信息 123456789101112## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别mybatis: mapper-locations: classpath:mapper/*.xml #注意：一定要对应mapper映射xml文件的所在路径 type-aliases-package: com.mypro.springbootmybatis.model # 注意：对应实体类的路径#pagehelperpagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql returnPageInfo: check 13. 测试，测试这里没有使用junit4了，使用的是postman这款工具 百度上有安装包，一路Next下去就好，记得切换安装地址，不要装在C盘 返回的结果如下： 看下pow.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 14. 配置日志resourcem目录下新建logback-spring.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration scan=\"true\" scanPeriod=\"10 seconds\"&gt; &lt;!--&lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt;--&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=\"log.path\" value=\"D:/log/winter\" /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\" /&gt; &lt;conversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\" /&gt; &lt;conversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\" /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=\"CONSOLE_LOG_PATTERN\" value=\"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;\"/&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt; &lt;appender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_debug.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 日志归档 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/debug/log-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录debug级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=\"ERROR_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、 以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前logger将会继承上级的级别。 addtivity:是否向上级logger传递打印信息。默认是true。 --&gt; &lt;!--&lt;logger name=\"org.springframework.web\" level=\"info\"/&gt;--&gt; &lt;!--&lt;logger name=\"org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor\" level=\"INFO\"/&gt;--&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=\"info\"&gt;改成&lt;root level=\"DEBUG\"&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别： --&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 不能设置为INHERITED或者同义词NULL。默认是DEBUG 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.winter\"/&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"DEBUG_FILE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;appender-ref ref=\"WARN_FILE\" /&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=\"pro\"&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"DEBUG_FILE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;appender-ref ref=\"WARN_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; application.yml最终版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354server: port: 8088spring:#激活哪一个环境的配置文件#公共配置 profiles: active: dev # pro为生产环境 dev为开发环境 jackson: date-format: yyyy-MM-dd HH:mm:ss datasource: name: mysql_test type: com.alibaba.druid.pool.DruidDataSource #druid相关配置 druid: #监控统计拦截的filters filters: stat driver-class-name: com.mysql.cj.jdbc.Driver #基本属性 url: jdbc:mysql://127.0.0.1:3306/winter?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: root password: luotao@1234 #配置初始化大小/最小/最大 initial-size: 1 min-idle: 1 max-active: 20 #获取连接等待超时时间 max-wait: 60000 #间隔多久进行一次检测，检测需要关闭的空闲连接 time-between-eviction-runs-millis: 60000 #一个连接在池中最小生存的时间 min-evictable-idle-time-millis: 300000 validation-query: SELECT &apos;x&apos; test-while-idle: true test-on-borrow: false test-on-return: false #打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false pool-prepared-statements: false max-pool-prepared-statement-per-connection-size: 20## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别mybatis: mapper-locations: classpath:mapper/*.xml #注意：一定要对应mapper映射xml文件的所在路径 type-aliases-package: com.mypro.springbootmybatis.model # 注意：对应实体类的路径#pagehelperpagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql returnPageInfo: checklogging: config: classpath:logback-spring.xml pom.xml最终版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;mypro.springbootmybatis&lt;/groupId&gt; &lt;artifactId&gt;springbootmybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootmybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如此IDEA集成spring boot+myBatis就已经完成了。 源码地址：https://github.com/whalesfalling/springboot-mybatis-demo","tags":[{"name":"SPringBoot整合","slug":"SPringBoot整合","permalink":"http://whalesfalling.github.io/tags/SPringBoot整合/"}]},{"title":"Hello World","date":"2019-03-16T15:13:59.804Z","path":"2019/03/16/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]